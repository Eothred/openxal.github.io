<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_31) on Thu Feb 05 15:44:30 EST 2015 -->
<title>CalculationsOnRings</title>
<meta name="date" content="2015-02-05">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="CalculationsOnRings";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../xal/tools/beam/calc/CalculationsOnParticles.html" title="class in xal.tools.beam.calc"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../xal/tools/beam/calc/ISimulationResults.html" title="interface in xal.tools.beam.calc"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?xal/tools/beam/calc/CalculationsOnRings.html" target="_top">Frames</a></li>
<li><a href="CalculationsOnRings.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">xal.tools.beam.calc</div>
<h2 title="Class CalculationsOnRings" class="title">Class CalculationsOnRings</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="../../../../xal/tools/beam/calc/CalculationEngine.html" title="class in xal.tools.beam.calc">xal.tools.beam.calc.CalculationEngine</a></li>
<li>
<ul class="inheritance">
<li><a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html" title="class in xal.tools.beam.calc">xal.tools.beam.calc.CalculationsOnMachines</a></li>
<li>
<ul class="inheritance">
<li>xal.tools.beam.calc.CalculationsOnRings</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../../../../xal/tools/beam/calc/ISimulationResults.html" title="interface in xal.tools.beam.calc">ISimulationResults</a>, <a href="../../../../xal/tools/beam/calc/ISimulationResults.ISimEnvResults.html" title="interface in xal.tools.beam.calc">ISimulationResults.ISimEnvResults</a>&lt;<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&gt;, <a href="../../../../xal/tools/beam/calc/ISimulationResults.ISimLocResults.html" title="interface in xal.tools.beam.calc">ISimulationResults.ISimLocResults</a>&lt;<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&gt;</dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">CalculationsOnRings</span>
extends <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html" title="class in xal.tools.beam.calc">CalculationsOnMachines</a></pre>
<div class="block"><p>
 Class for computing ring parameters from simulation data.
 Accepts a <code>TransferMapTrajectory</code> as ring simulation data
 (from the online model) and computes the ring parameters from the 
 transfer maps stored around the ring.  Thus, the trajectory provided 
 <b>must</b> be the end-to-end simulation results of the ring.  The entrance
 of the first state in the trajectory and the exit of the last state in the
 trajectory will be treated as the same point, <i>s</i> = 0.
 </p>
 Do not supply partial simulations!  Use the trajectory for the full ring
 unless it is your intent to create a sub-ring.  That is, do not use the start element
 and stop element features of the online model unless you wish to simulate
 a smaller ring that excludes all elements before the stop element and all 
 elements after the stop element.  In such a case the entrance of the start
 element and the exit of the stop element would close the ring and be given
 the point <i>s</i> = 0.
 </p>
 <p>
 The method names are those of interfaces <code>ICoordinateState</code>
 and </code>IPhaseState</code> to reflect their intent.  However, they
 should be changed to something more descriptive once refactoring
 is finished.  Preferably a method prefixed with <tt>calculate</tt>
 since the current naming scheme conflicts with Javabeans, specifically,
 the <code>get</code> prefix indicates a property of this class where in 
 actuality it is a computation.
 </p>
 <p>
 Do not hesitate to request new features and computations that could be provided
 by this class, it is by no means complete.
 </p></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Oct 22, 2013</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.xal.tools.beam.calc.ISimulationResults">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;xal.tools.beam.calc.<a href="../../../../xal/tools/beam/calc/ISimulationResults.html" title="interface in xal.tools.beam.calc">ISimulationResults</a></h3>
<code><a href="../../../../xal/tools/beam/calc/ISimulationResults.ISimEnvResults.html" title="interface in xal.tools.beam.calc">ISimulationResults.ISimEnvResults</a>&lt;<a href="../../../../xal/tools/beam/calc/ISimulationResults.ISimEnvResults.html" title="type parameter in ISimulationResults.ISimEnvResults">S</a>&gt;, <a href="../../../../xal/tools/beam/calc/ISimulationResults.ISimLocResults.html" title="interface in xal.tools.beam.calc">ISimulationResults.ISimLocResults</a>&lt;<a href="../../../../xal/tools/beam/calc/ISimulationResults.ISimLocResults.html" title="type parameter in ISimulationResults.ISimLocResults">S</a>&gt;</code></li>
</ul>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#CalculationsOnRings-xal.model.probe.traj.Trajectory-">CalculationsOnRings</a></span>(<a href="../../../../xal/model/probe/traj/Trajectory.html" title="class in xal.model.probe.traj">Trajectory</a>&lt;<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&gt;&nbsp;datSim)</code>
<div class="block">
 Constructor for CalculationsOnRings.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="../../../../xal/tools/math/r3/R3.html" title="class in xal.tools.math.r3">R3</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#computeFractionalTunes--">computeFractionalTunes</a></span>()</code>
<div class="block">
 Calculates the fractional phase tune for the ring from its one-turn matrix.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="../../../../xal/tools/math/r3/R3.html" title="class in xal.tools.math.r3">R3</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#computeFullTunes--">computeFullTunes</a></span>()</code>
<div class="block">
 Calculates and returns the full tune around the ring including the integer portion.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="../../../../xal/tools/beam/Twiss.html" title="class in xal.tools.beam">Twiss</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#computeMatchedTwissAt-xal.model.probe.traj.TransferMapState-">computeMatchedTwissAt</a></span>(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state)</code>
<div class="block">
 Calculates the matched Courant-Snyder parameters for the given
 state location.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../../xal/tools/math/r3/R3.html" title="class in xal.tools.math.r3">R3</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#computePhaseAdvanceBetween-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-">computePhaseAdvanceBetween</a></span>(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state1,
                          <a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state2)</code>
<div class="block">Computes the phase advances between the given state locations for each phase plane.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="../../../../xal/tools/beam/PhaseMatrix.html" title="class in xal.tools.beam">PhaseMatrix</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#computeRingFullTurnMatrixAt-xal.model.probe.traj.TransferMapState-">computeRingFullTurnMatrixAt</a></span>(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state)</code>
<div class="block">Computes the one-turn matrix of the ring at the given state location.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="../../../../xal/tools/beam/PhaseMap.html" title="class in xal.tools.beam">PhaseMap</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#computeRingTransferMap-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-">computeRingTransferMap</a></span>(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state1,
                      <a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state2)</code>
<div class="block">
 Returns the transfer map <b>T</b><sub>2,1</sub> taking phase 
 coordinates from state position 
 <i>S</i><sub>1</sub> to state position <i>S</i><sub>2</sub> within the ring.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="../../../../xal/tools/beam/PhaseMatrix.html" title="class in xal.tools.beam">PhaseMatrix</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#computeRingTransferMatrix-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-">computeRingTransferMatrix</a></span>(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state1,
                         <a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state2)</code>
<div class="block">
 Returns the transfer matrix <b>&Phi;</b><sub>2,1</sub> taking phase 
 coordinates from state position 
 <i>S</i><sub>1</sub> to state position <i>S</i><sub>2</sub> within the ring.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../../../../xal/tools/beam/PhaseVector.html" title="class in xal.tools.beam">PhaseVector</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#computeTurnByTurnResponse-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-int-xal.tools.beam.PhaseVector-">computeTurnByTurnResponse</a></span>(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;stateInj,
                         <a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;stateObs,
                         int&nbsp;cntTurns,
                         <a href="../../../../xal/tools/beam/PhaseVector.html" title="class in xal.tools.beam">PhaseVector</a>&nbsp;vecInj)</code>
<div class="block">
 Computes and returns the turn-by-turn phase positions 
 {<b>z</b><sub><i>n</i></sub> &in; <b>R</b><sup>6</sup> &times; {1} | <i>n</i>=0,...,<i>N</i>-1 }
 at the given location <i>s</i><sub>obs</sub> of state <i>S</i><sub>obs</sub> resulting 
 from a particle injected
 at location <i>s</i><sub>inj</sub> &in; <i>S</i><sub>inj</sub> with initial phase 
 coordinates <b>z</b><sub>inj</sub>.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="../../../../xal/tools/beam/PhaseVector.html" title="class in xal.tools.beam">PhaseVector</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#computeTurnByTurnRespWrtFixedOrbit-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-int-xal.tools.beam.PhaseVector-">computeTurnByTurnRespWrtFixedOrbit</a></span>(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;stateInj,
                                  <a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;stateObs,
                                  int&nbsp;cntTurns,
                                  <a href="../../../../xal/tools/beam/PhaseVector.html" title="class in xal.tools.beam">PhaseVector</a>&nbsp;vecInj)</code>
<div class="block">
 Computes and returns the turn-by-turn phase positions 
 {<b>z</b><sub><i>n</i></sub> &in; <b>R</b><sup>6</sup> &times; {1} | <i>n</i>=0,...,<i>N</i>-1 }
 at the given location <i>s</i><sub>obs</sub> of state <i>S</i><sub>obs</sub> resulting 
 from a particle injected
 at location <i>s</i><sub>inj</sub> &in; <i>S</i><sub>inj</sub> with initial phase 
 coordinates <b>z</b><sub>inj</sub>.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="../../../../xal/tools/beam/PhaseMap.html" title="class in xal.tools.beam">PhaseMap</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#getOneTurnMap--">getOneTurnMap</a></span>()</code>
<div class="block">Returns the one-turn map <b>&Phi;</b><sub>0</sub> for the ring at the location
 <i>s</i> = 0.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="../../../../xal/tools/math/r3/R3.html" title="class in xal.tools.math.r3">R3</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#ringBetatronPhaseAdvance--">ringBetatronPhaseAdvance</a></span>()</code>
<div class="block">
 Returns the betatron phase advances for the ring entrance (which are computed 
 at instantiation).</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="../../../../xal/tools/beam/PhaseVector.html" title="class in xal.tools.beam">PhaseVector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#ringFixedOrbitPt--">ringFixedOrbitPt</a></span>()</code>
<div class="block">
 Returns the phase space location of the fixed orbit at the ring entrance 
 (which is computed at instantiation).</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="../../../../xal/tools/beam/Twiss.html" title="class in xal.tools.beam">Twiss</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../xal/tools/beam/calc/CalculationsOnRings.html#ringMatchedTwiss--">ringMatchedTwiss</a></span>()</code>
<div class="block">
 Returns the matched Courant-Snyder parameters at the "entrance" of the ring.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.xal.tools.beam.calc.CalculationsOnMachines">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;xal.tools.beam.calc.<a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html" title="class in xal.tools.beam.calc">CalculationsOnMachines</a></h3>
<code><a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#calculateFullLatticeMatrixAt-xal.model.probe.traj.TransferMapState-">calculateFullLatticeMatrixAt</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#computeBetatronPhase-xal.model.probe.traj.TransferMapState-">computeBetatronPhase</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#computeChromAberration-xal.model.probe.traj.TransferMapState-">computeChromAberration</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#computeChromDispersion-xal.model.probe.traj.TransferMapState-">computeChromDispersion</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#computeCoordinatePosition-xal.model.probe.traj.TransferMapState-">computeCoordinatePosition</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#computeFixedOrbit-xal.model.probe.traj.TransferMapState-">computeFixedOrbit</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#computeTransferMap-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-">computeTransferMap</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#computeTransferMatrix-java.lang.String-java.lang.String-">computeTransferMatrix</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#computeTransferMatrix-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-">computeTransferMatrix</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#computeTwissParameters-xal.model.probe.traj.TransferMapState-">computeTwissParameters</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#getFullTransferMap--">getFullTransferMap</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#getMatchedTwiss--">getMatchedTwiss</a>, <a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#getTrajectory--">getTrajectory</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.xal.tools.beam.calc.CalculationEngine">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;xal.tools.beam.calc.<a href="../../../../xal/tools/beam/calc/CalculationEngine.html" title="class in xal.tools.beam.calc">CalculationEngine</a></h3>
<code><a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculateAberration-xal.tools.beam.PhaseMatrix-double-">calculateAberration</a>, <a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculateDispersion-xal.tools.beam.PhaseMatrix-double-">calculateDispersion</a>, <a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculateFixedPoint-xal.tools.beam.PhaseMatrix-">calculateFixedPoint</a>, <a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculateMatchedTwiss-xal.tools.beam.PhaseMatrix-">calculateMatchedTwiss</a>, <a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculatePhaseAdvance_old-xal.tools.beam.PhaseMatrix-xal.tools.beam.Twiss:A-xal.tools.beam.Twiss:A-">calculatePhaseAdvance_old</a>, <a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculatePhaseAdvance-xal.tools.beam.PhaseMatrix-xal.tools.beam.Twiss:A-xal.tools.beam.Twiss:A-">calculatePhaseAdvance</a>, <a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculatePhaseAdvPerCell-xal.tools.beam.PhaseMatrix-">calculatePhaseAdvPerCell</a>, <a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculateTunePerCell-xal.tools.beam.PhaseMatrix-">calculateTunePerCell</a>, <a href="../../../../xal/tools/beam/calc/CalculationEngine.html#computeTwiss-xal.model.probe.TwissProbe-xal.tools.beam.PhaseMatrix-double-">computeTwiss</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="CalculationsOnRings-xal.model.probe.traj.Trajectory-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>CalculationsOnRings</h4>
<pre>public&nbsp;CalculationsOnRings(<a href="../../../../xal/model/probe/traj/Trajectory.html" title="class in xal.model.probe.traj">Trajectory</a>&lt;<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&gt;&nbsp;datSim)</pre>
<div class="block"><p>
 Constructor for CalculationsOnRings. The the ring is closed by identifying 
 the first and last states in the provided trajectory.
 </p>
 <p>  
 Parameters that are required for subsequent ring parameter calculations are 
 computed, such as "entrance" position phase advance, "entrance" position 
 fixed orbit, and "entrance" position matched envelope. By entrance position
 we imply the location <i>s</i> = 0, the location of ring closure.  Once these
 quantities are computed we can propagate them to other ring locations as needed.
 </p>
 <p>
 For example, the transfer map of the last state in the trajectory
 is the full turn map of the ring at the entrance position.  By conjugation
 with transfer map of any other state we can form the transfer map at that
 state location.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>trjSimFull</code> - the simulation data for <em>entire</em> ring, a "transfer map trajectory" object</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - the trajectory does not contain <code>TransferMapState</code> objects</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Oct 22, 2013</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="ringBetatronPhaseAdvance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ringBetatronPhaseAdvance</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/math/r3/R3.html" title="class in xal.tools.math.r3">R3</a>&nbsp;ringBetatronPhaseAdvance()</pre>
<div class="block"><p>
 Returns the betatron phase advances for the ring entrance (which are computed 
 at instantiation).  The returned value is the calculation
 <code><a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculatePhaseAdvPerCell-xal.tools.beam.PhaseMatrix-"><code>CalculationEngine.calculatePhaseAdvPerCell(PhaseMatrix)</code></a></code> given the
 full turn matrix at the ring entrance.
 </p>
 <p>  
 <h4>NOTES:</h4>
 &middot; The ring tunes and betatron phase advances differ by a factor 2&pi;.
 <br/>
 &middot; The entrance of the ring is assumed to be the location of the
 first and last states of the solution trajectory.
 </p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vector particle betatron phase advances (in radians)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Oct 30, 2013</dd>
</dl>
</li>
</ul>
<a name="ringFixedOrbitPt--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ringFixedOrbitPt</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/beam/PhaseVector.html" title="class in xal.tools.beam">PhaseVector</a>&nbsp;ringFixedOrbitPt()</pre>
<div class="block"><p>
 Returns the phase space location of the fixed orbit at the ring entrance 
 (which is computed at instantiation). The returned value <b>z</b> is the result of the
 calculation <code><a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculateFixedPoint-xal.tools.beam.PhaseMatrix-"><code>CalculationEngine.calculateFixedPoint(PhaseMatrix)</code></a></code> given the
 full turn matrix <b>&Phi;</b> at the ring entrance. It is invariant under 
 the action of <b>&Phi;</b>, that is, <b>&Phi;z</b> = <b>z</b>. 
 </p>
 <p>  
 <h4>NOTES:</h4>
 &middot; The entrance of the ring is assumed to be the location of the
 first and last states of the solution trajectory.
 </p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Oct 30, 2013</dd>
</dl>
</li>
</ul>
<a name="ringMatchedTwiss--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ringMatchedTwiss</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/beam/Twiss.html" title="class in xal.tools.beam">Twiss</a>[]&nbsp;ringMatchedTwiss()</pre>
<div class="block"><p>
 Returns the matched Courant-Snyder parameters at the "entrance" of the ring. These
 are the envelopes taken from the "closed envelope" solution at the beginning
 of the ring, <i>s</i> = 0.
 </p>
 <p>
 Note that emittance &epsilon; is the parameter used to describe the extend of
 the actual beam (rather than the normalized size &beta;), or "acceptance".  Thus it
 cannot be computed here and <code>NaN</code> is returned instead.
 </p>
 <p>  
 <h4>NOTES:</h4>
 &middot; The entrance of the ring is assumed to be the location of the
 first and last states of the solution trajectory.
 </p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of Twiss parameter sets (&alpha;, &beta;, NaN)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Oct 30, 2013</dd>
</dl>
</li>
</ul>
<a name="getOneTurnMap--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOneTurnMap</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/beam/PhaseMap.html" title="class in xal.tools.beam">PhaseMap</a>&nbsp;getOneTurnMap()</pre>
<div class="block">Returns the one-turn map <b>&Phi;</b><sub>0</sub> for the ring at the location
 <i>s</i> = 0.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>ring one-turn map at join location</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Nov 4, 2014</dd>
</dl>
</li>
</ul>
<a name="computePhaseAdvanceBetween-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computePhaseAdvanceBetween</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/math/r3/R3.html" title="class in xal.tools.math.r3">R3</a>&nbsp;computePhaseAdvanceBetween(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state1,
                                     <a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state2)</pre>
<div class="block">Computes the phase advances between the given state locations for each phase plane.
 This is done by computing the matched Twiss parameters at the two locations, along
 with the transfer matrix, then computing the phase advances &sigma; using is
 its entries in the transfer matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>state1</code> - state defining the start location in the ring</dd>
<dd><code>state2</code> - state defining the stop location in the ring</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>phases advances (&sigma;<sub><i>x</i></sub>, &sigma;<sub><i>y</i></sub>, &sigma;<sub><i>z</i></sub>)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Nov 7, 2014</dd>
</dl>
</li>
</ul>
<a name="computeFractionalTunes--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeFractionalTunes</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/math/r3/R3.html" title="class in xal.tools.math.r3">R3</a>&nbsp;computeFractionalTunes()</pre>
<div class="block"><p>
 Calculates the fractional phase tune for the ring from its one-turn matrix.
 The Courant-Snyder parameters 
 of the machine (beam) must be invariant under the action of the one-turn matrix 
 (this indicates a periodic focusing structure 
 where the beam envelope is modulated by that structure) for the returned values
 to be accurate.  One tune parameter
 is provided for each phase plane, i.e., 
 (&nu;<sub><i>x</i></sub>, &nu;<sub><i>y</i></sub>, &nu;<sub><i>z</i></sub>).  
 The betatron phase advances for the ring are then given by 
 (2&pi;&nu;<sub><i>x</i></sub>, 2&pi;&nu;<sub><i>y</i></sub>, 2&pi;&nu;<sub><i>z</i></sub>).  
 Specifically, the above values are the sinusoidal phase that a particle
 advances after each completion of a ring traversal, modulo 2&pi; 
 (that is, we only take the fractional part).
 </p>
 <p>
 The basic computation is 
 <br/>
 <br/>
 &nbsp; &nbsp;  &nu; = (1/2&pi;) cos<sup>-1</sup>[&frac12; Tr <b>&Phi;</b><sub>&alpha;&alpha;</sub>] ,
 <br/>
 <br/>
 where <b>&Phi;</b></b><sub>&alpha;&alpha;</sub> is the 2&times;2 block diagonal 
 of the the provided transfer matrix for the &alpha; phase plane, 
 and Tr <b>&Phi;</b></b><sub>&alpha;&alpha;</sub> indicates the trace of matrix 
 <b>&Phi;</b></b><sub>&alpha;&alpha;</sub>.
 </p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vector of fractional tunes (&nu;<sub><i>x</i></sub>, &nu;<sub><i>y</i></sub>, &nu;<sub><i>z</i></sub>)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Nov 4, 2014</dd>
</dl>
</li>
</ul>
<a name="computeFullTunes--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeFullTunes</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/math/r3/R3.html" title="class in xal.tools.math.r3">R3</a>&nbsp;computeFullTunes()</pre>
<div class="block"><p>
 Calculates and returns the full tune around the ring including the integer portion.
 The tunes are computed for the start of the ring.
 The tune for each phase plane is returned in the 3-dimensional vector.
 </p>
 <p>
 The full tunes are computed by summing all the partial phase advances
 through each of the trajectory states (see 
 <code><a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculatePhaseAdvance-xal.tools.beam.PhaseMatrix-xal.tools.beam.Twiss:A-xal.tools.beam.Twiss:A-"><code>CalculationEngine.calculatePhaseAdvance(PhaseMatrix, Twiss[], Twiss[])</code></a></code>).  
 Thus, the partial phase advance
 through each state must also be computed so <em>this can be an
 expensive operation</em>.
 </p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number <i>n.&nu;</i> for each phase plane where <i>n</i> is the 
          integer portion and <i>&nu;</i> is the fractional phase advance.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Oct 24, 2013</dd>
</dl>
</li>
</ul>
<a name="computeRingFullTurnMatrixAt-xal.model.probe.traj.TransferMapState-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeRingFullTurnMatrixAt</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/beam/PhaseMatrix.html" title="class in xal.tools.beam">PhaseMatrix</a>&nbsp;computeRingFullTurnMatrixAt(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state)</pre>
<div class="block">Computes the one-turn matrix of the ring at the given state location.
 Let <i>S<sub>n</sub></i> be the given state object at
 location <i>s<sub>n</sub></i>, and let <b>T</b><sub><i>n</i></sub> be the
 transfer matrix between locations <i>s</i><sub>0</sub> and <i>s<sub>n</sub></i> ,
 where <i>s</i><sub>0</sub> is the location of the full one-turn matrix 
 <b>&Phi;</b><sub>0</sub> for this machine at position <i>s</i> = 0 (which is the
 beginning and the end of the trajectory object used to construct this class
 instance).  Then the full turn matrix 
 <b>&Phi;</b><sub><i>n</i></sub> for the machine at location <i>s<sub>n</sub></i>
 is given by
 <br/>
 <br/>
 &nbsp; &nbsp; <b>&Phi;</b><sub><i>n</i></sub> = <b>T</b><sub><i>n</i></sub> &sdot; <b>&Phi;</b><sub>0</sub>
               &sdot; <b>T</b><sub><i>n</i></sub><sup>-1</sup> .
 <br/>
 <br/>
 That is, we conjugate the full transfer map for this machine by the transfer map 
 for the given state.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>state</code> - state <i>S<sub>n</sub></i> identifying the position <i>s<sub>n</sub></i></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The one-turn matrix <b>&Phi;</b><sub><i>n</i></sub> of the ring at <i>s<sub>n</sub></i></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Nov 4, 2014</dd>
</dl>
</li>
</ul>
<a name="computeRingTransferMatrix-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeRingTransferMatrix</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/beam/PhaseMatrix.html" title="class in xal.tools.beam">PhaseMatrix</a>&nbsp;computeRingTransferMatrix(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state1,
                                             <a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state2)</pre>
<div class="block"><p>
 Returns the transfer matrix <b>&Phi;</b><sub>2,1</sub> taking phase 
 coordinates from state position 
 <i>S</i><sub>1</sub> to state position <i>S</i><sub>2</sub> within the ring.
 This is the first-order portion of the ring's transfer map <b>T</b><sub>2,1</sub>
 between states <i>S</i><sub>1</sub> and <i>S</i><sub>2</sub> 
 (see method 
 <code><a href="../../../../xal/tools/beam/calc/CalculationsOnMachines.html#computeTransferMap-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-"><code>CalculationsOnMachines.computeTransferMap(TransferMapState, TransferMapState)</code></a></code>). 
 </p>
 <p>
 Because of the ring topology, position <i>s</i><sub>1</sub> of state 
 <i>S</i><sub>1</sub> and position  <i>s</i><sub>2</sub> of state 
 <i>S</i><sub>2</sub> are really equivalence classes of real numbers
 [<i>s</i><sub>1</sub>] &sub; <b>R</b> and [<i>s</i><sub>2</sub>] &sub; <b>R</b>,
 respectively.  Each equivalence class can be represented
 <br/>
 <br/>
 &nbsp; &nbsp; [<i>s<sub>i</sub></i> ] = { <i>s<sub>i</sub></i> + <i>nL</i> | <i>n</i> &in; <b>Z</b><sub>+</sub> } 
 <br/>
 <br/>
 where <i>L</i> is the circumference of the ring.  Because of the way the ring
 is represented as a data structure, we have <i>s</i> &in; [0,<i>L</i>]. 
 However, we must enforce the condition that <i>s</i><sub>2</sub> is always
 "down stream" of <i>s</i><sub>1</sub>.  Specifically,
 we do not reverse directions when computing the transfer matrix.
 Here we describe the calculations in practical detail.
 </p>
 <p>
 If while traveling downstream from position <i>s</i><sub>1</sub> we need to
 determine whether or not we pass the position <i>s</i> = 0 before we encounter
 the position <i>s</i><sub>2</sub>. If so we to represent the position of 
 state <i>S</i><sub>2</sub> as 
 <i>s</i><sub>2</sub> + <i>L</i> &in; [<i>s</i><sub>2</sub>], since 
 <i>s</i><sub>2</sub> &lt; <i>s</i></sub>1</sub> indicating <i>s</i><sub>2</sub>
 is upstream of <i>s</i><sub>1</sub> (according to our model).  This condition
 requires that we must include the ring full turn matrix <b>&Phi;</b><sub>0</sub>
 when computing the transfer matrix.  Recall that <b>&Phi;</b><sub>0</sub> takes
 phase coordinates from position <i>s</i> = 0
 to position <i>s</i = 0 going all the way around the ring. 
 </p>
 <p>
 Collecting all of the above, if <i>s</i><sub>2</sub> &lt; <i>s</i><sub>1</sub> 
 then we have a propagation through point <i>s</i> = 0 and we must include the
 full turn matrix according to
 <br/>
 <br/>
 &nbsp; &nbsp; <b>&Phi;</b><sub>2,1</sub> = <b>&Phi;</b><sub>2</sub><b>&Phi;</b><sub>0</sub><b>&Phi;</b><sub>1</sub><sup>-1</sup> .
 <br/>
 <br/> 
 If <i>s</i><sub>2</sub> &gt; <i>s</i><sub>1</sub> then we can compute the transfer
 matrix <b>&Phi;</b><sub>2,1</sub> in the usual fashion
 <br/>
 <br/>
 &nbsp; &nbsp; <b>&Phi;</b><sub>2,1</sub> = <b>&Phi;</b><sub>2</sub><b>&Phi;</b><sub>1</sub><sup>-1</sup> .
 <br/>
 <br/> 
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>state1</code> - phase state <i>S</i><sub>1</sub> defining ring position <i>s</i><sub>1</sub></dd>
<dd><code>state2</code> - phase state <i>S</i><sub>2</sub> defining ring position <i>s</i><sub>2</sub></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the transfer matrix <b>&Phi;</b><sub>2,1</sub> taking phase coordinates <b>z</b> from
          position <i>s</i><sub>1</sub> on the ring to position <i>s</i><sub>2</sub></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Nov 3, 2014</dd>
</dl>
</li>
</ul>
<a name="computeRingTransferMap-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeRingTransferMap</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/beam/PhaseMap.html" title="class in xal.tools.beam">PhaseMap</a>&nbsp;computeRingTransferMap(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state1,
                                       <a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state2)</pre>
<div class="block"><p>
 Returns the transfer map <b>T</b><sub>2,1</sub> taking phase 
 coordinates from state position 
 <i>S</i><sub>1</sub> to state position <i>S</i><sub>2</sub> within the ring.
 </p>
 <p>
 Because of the ring topology, position <i>s</i><sub>1</sub> of state 
 <i>S</i><sub>1</sub> and position  <i>s</i><sub>2</sub> of state 
 <i>S</i><sub>2</sub> are really equivalence classes of real numbers
 [<i>s</i><sub>1</sub>] &sub; <b>R</b> and [<i>s</i><sub>2</sub>] &sub; <b>R</b>,
 respectively.  Each equivalence class can be represented
 <br/>
 <br/>
 &nbsp; &nbsp; [<i>s<sub>i</sub></i> ] = { <i>s<sub>i</sub></i> + <i>nL</i> | <i>n</i> &in; <b>Z</b><sub>+</sub> } 
 <br/>
 <br/>
 where <i>L</i> is the circumference of the ring.  Because of the way the ring
 is represented as a data structure, we have <i>s</i> &in; [0,<i>L</i>]. 
 However, we must enforce the condition that <i>s</i><sub>2</sub> is always
 "down stream" of <i>s</i><sub>1</sub>.  Specifically,
 we do not reverse directions when computing the transfer map.
 Here we describe the calculations in practical detail.
 </p>
 <p>
 If while traveling downstream from position <i>s</i><sub>1</sub> we need to
 determine whether or not we pass the position <i>s</i> = 0 before we encounter
 the position <i>s</i><sub>2</sub>. If so we to represent the position of 
 state <i>S</i><sub>2</sub> as 
 <i>s</i><sub>2</sub> + <i>L</i> &in; [<i>s</i><sub>2</sub>], since 
 <i>s</i><sub>2</sub> &lt; <i>s</i></sub>1</sub> indicating <i>s</i><sub>2</sub>
 is upstream of <i>s</i><sub>1</sub> (according to our model).  This condition
 requires that we must include the ring full turn map <b>T</b><sub>0</sub>
 when computing the transfer map.  Recall that <b>T</b><sub>0</sub> takes
 phase coordinates from position <i>s</i> = 0
 to position <i>s</i = 0 going all the way around the ring. 
 </p>
 <p>
 Collecting all of the above, if <i>s</i><sub>2</sub> &lt; <i>s</i><sub>1</sub> 
 then we have a propagation through point <i>s</i> = 0 and we must include the
 full turn map according to
 <br/>
 <br/>
 &nbsp; &nbsp; <b>T</b><sub>2,1</sub> = <b>T</b><sub>2</sub><b>T</b><sub>0</sub><b>T</b><sub>1</sub><sup>-1</sup> .
 <br/>
 <br/> 
 If <i>s</i><sub>2</sub> &gt; <i>s</i><sub>1</sub> then we can compute the transfer
 map <b>T</b><sub>2,1</sub> in the usual fashion
 <br/>
 <br/>
 &nbsp; &nbsp; <b>T</b><sub>2,1</sub> = <b>T</b><sub>2</sub><b>T</b><sub>1</sub><sup>-1</sup> .
 <br/>
 <br/> 
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>state1</code> - phase state <i>S</i><sub>1</sub> defining ring position <i>s</i><sub>1</sub></dd>
<dd><code>state2</code> - phase state <i>S</i><sub>2</sub> defining ring position <i>s</i><sub>2</sub></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the transfer map <b>T</b><sub>2,1</sub> taking phase coordinates <b>z</b> from
          position <i>s</i><sub>1</sub> on the ring to position <i>s</i><sub>2</sub></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Nov 3, 2014</dd>
</dl>
</li>
</ul>
<a name="computeTurnByTurnResponse-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-int-xal.tools.beam.PhaseVector-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeTurnByTurnResponse</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/beam/PhaseVector.html" title="class in xal.tools.beam">PhaseVector</a>[]&nbsp;computeTurnByTurnResponse(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;stateInj,
                                               <a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;stateObs,
                                               int&nbsp;cntTurns,
                                               <a href="../../../../xal/tools/beam/PhaseVector.html" title="class in xal.tools.beam">PhaseVector</a>&nbsp;vecInj)</pre>
<div class="block"><p>
 Computes and returns the turn-by-turn phase positions 
 {<b>z</b><sub><i>n</i></sub> &in; <b>R</b><sup>6</sup> &times; {1} | <i>n</i>=0,...,<i>N</i>-1 }
 at the given location <i>s</i><sub>obs</sub> of state <i>S</i><sub>obs</sub> resulting 
 from a particle injected
 at location <i>s</i><sub>inj</sub> &in; <i>S</i><sub>inj</sub> with initial phase 
 coordinates <b>z</b><sub>inj</sub>.  
 </p>
 <p>
 The coordinates <b>z</b><sub><i>n</i></sub>
 are taken with respect to the ring's fixed point orbit <b>p</b> at location 
 <i>s</i><sub>obj</sub>.  That is, each <b>z</b><sub><i>n</i></sub> is a displacement
 from <b>p</b> in the global coordinate system.
 </p>
 <p>
 Currently the computation is entirely matrix based.  Only transfer matrices
 are used and not transfer maps.  Specifically, let <b>&Phi;</b><sub>2,1</sub> be the
 transfer matrix from <i>s</i><sub>1</sub> &#8796; <i>s</i><sub>inj</sub> to 
 <i>s</i><sub>2</sub> &#8796; <i>s</i><sub>obs</sub> and let 
 <b>&Phi;</b><sub>2,2</sub> be the one-turn map at position <i>s</i><sub>2</sub> in 
 the ring. Then the returned array of phase vectors {<b>z</b><sub><i>n</i></sub> } is
 given by
 <br/>
 <br/>
 &nbsp; &nbsp; <b>z</b><sub><i>n</i></sub> = [<b>&Phi;</b><sub>2,2</sub>]<sup><i>n</i></sup> 
                                             <b>&Phi;</b><sub>2,1</sub> <b>z</b><sub>inj</sub> .
 <br/>
 <br/>
 Note that <b>z</b><sub>0</sub> is <b>&Phi;</b><sub>2,1</sub> <b>z</b><sub>inj</sub> , the
 phase coordinates of the particle after propagating from the injection location to the
 observation location.                                     
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateInj</code> - trajectory state at the injection location</dd>
<dd><code>stateObs</code> - trajectory state at the observation location</dd>
<dd><code>cntTurns</code> - number of turns <i>N</i> to observe particle</dd>
<dd><code>vecInj</code> - the initial phase coordinates in the ring global coordinate system</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of phase coordinates representing displacements from the fixed orbit</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Nov 4, 2014</dd>
</dl>
</li>
</ul>
<a name="computeTurnByTurnRespWrtFixedOrbit-xal.model.probe.traj.TransferMapState-xal.model.probe.traj.TransferMapState-int-xal.tools.beam.PhaseVector-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeTurnByTurnRespWrtFixedOrbit</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/beam/PhaseVector.html" title="class in xal.tools.beam">PhaseVector</a>[]&nbsp;computeTurnByTurnRespWrtFixedOrbit(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;stateInj,
                                                        <a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;stateObs,
                                                        int&nbsp;cntTurns,
                                                        <a href="../../../../xal/tools/beam/PhaseVector.html" title="class in xal.tools.beam">PhaseVector</a>&nbsp;vecInj)</pre>
<div class="block"><p>
 Computes and returns the turn-by-turn phase positions 
 {<b>z</b><sub><i>n</i></sub> &in; <b>R</b><sup>6</sup> &times; {1} | <i>n</i>=0,...,<i>N</i>-1 }
 at the given location <i>s</i><sub>obs</sub> of state <i>S</i><sub>obs</sub> resulting 
 from a particle injected
 at location <i>s</i><sub>inj</sub> &in; <i>S</i><sub>inj</sub> with initial phase 
 coordinates <b>z</b><sub>inj</sub>.
 </p>
 <p>
 Currently the computation is entirely matrix based.  Only transfer matrices
 are used and not transfer maps.  Specifically, let <b>&Phi;</b><sub>2,1</sub> be the
 transfer matrix from <i>s</i><sub>1</sub> &#8796; <i>s</i><sub>inj</sub> to 
 <i>s</i><sub>2</sub> &#8796; <i>s</i><sub>obs</sub> and let 
 <b>&Phi;</b><sub>2,2</sub> be the one-turn map at position <i>s</i><sub>2</sub> in 
 the ring. Then the returned array of phase vectors {<b>z</b><sub><i>n</i></sub> } is
 given by
 <br/>
 <br/>
 &nbsp; &nbsp; <b>z</b><sub><i>n</i></sub> = [<b>&Phi;</b><sub>2,2</sub>]<sup><i>n</i></sup> 
                                             <b>&Phi;</b><sub>2,1</sub> <b>z</b><sub>inj</sub> .
 <br/>
 <br/>
 Note that <b>z</b><sub>0</sub> is <b>&Phi;</b><sub>2,1</sub> <b>z</b><sub>inj</sub> , the
 phase coordinates of the particle after propagating from the injection location to the
 observation location.                                     
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateInj</code> - trajectory state at the injection location</dd>
<dd><code>stateObs</code> - trajectory state at the observation location</dd>
<dd><code>cntTurns</code> - number of turns <i>N</i> to observe particle</dd>
<dd><code>vecInj</code> - the initial phase coordinates w.r.t. to the fixed orbit location</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of phase coordinates representing displacements from the fixed orbit</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Nov 4, 2014</dd>
</dl>
</li>
</ul>
<a name="computeMatchedTwissAt-xal.model.probe.traj.TransferMapState-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>computeMatchedTwissAt</h4>
<pre>public&nbsp;<a href="../../../../xal/tools/beam/Twiss.html" title="class in xal.tools.beam">Twiss</a>[]&nbsp;computeMatchedTwissAt(<a href="../../../../xal/model/probe/traj/TransferMapState.html" title="class in xal.model.probe.traj">TransferMapState</a>&nbsp;state)</pre>
<div class="block"><p>
 Calculates the matched Courant-Snyder parameters for the given
 state location.  The computed Twiss parameters are the matched
 envelopes for the ring at that point.
 </p>
 <p>
 Internally, the array of phase advances 
 {&sigma;<sub><i>x</i></sub>, &sigma;<sub><i>y</i></sub>, &sigma;<sub><i>x</i></sub>}
 are assumed to be the particle phase advances through the ring for the matched 
 solution.   These are computed with the base class method 
 <code><a href="../../../../xal/tools/beam/calc/CalculationEngine.html#calculatePhaseAdvPerCell-xal.tools.beam.PhaseMatrix-"><code>CalculationEngine.calculatePhaseAdvPerCell(PhaseMatrix)</code></a></code>.
 </p> 
 <p>
 The returned Courant-Snyder parameters (&alpha;, &beta;, &epsilon;) are invariant
 under the action of the one-turn matrix at the state location, that is, 
 they are matched.  All that 
 is required are &alpha; and &beta; since &epsilon; specifies the size of the beam
 envelope.  Consequently the returned &epsilon; is <code>NaN</code>.
 </p>
 The following are the calculations used for the Courant-Snyder parameters of a 
 single phase plane:
 <br/>
 <br/>
 &nbsp; &nbsp; &alpha; &equiv; -<i>ww'</i> = (&phi;<sub>11</sub> - &phi;<sub>22</sub>)/(2 sin &sigma;) ,
 <br/>
 <br/>
 &nbsp; &nbsp; &beta; &equiv; <i>w</i><sup>2</sup> = &phi;<sub>12</sub>/sin &sigma;
 <br/>
 <br/>
 where &phi;<sub><i>ij</i></sub> are the elements of the 2&times;2 diagonal blocks of
 the one-turn matrix <b>&Phi;</b> for the the particular phase plane. The particle 
 amplitude function <i>w</i>
 is taken from Reiser, and &sigma; is the phase advance through the cell for the 
 particular phase plane.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>state</code> - state defining the location for computing the matched Twiss parameters</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>matched Twiss parameters at the given state location</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Nov 5, 2014</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../xal/tools/beam/calc/CalculationsOnParticles.html" title="class in xal.tools.beam.calc"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../xal/tools/beam/calc/ISimulationResults.html" title="interface in xal.tools.beam.calc"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?xal/tools/beam/calc/CalculationsOnRings.html" target="_top">Frames</a></li>
<li><a href="CalculationsOnRings.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
